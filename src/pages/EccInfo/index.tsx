import React from 'react';

import './index.less';

const EccInfo = () => {
  return (
    <div className='ecc-info'>
      <h2>什么是ECC</h2>
      <p>ECC是Elliptic Curve Cryptography（椭圆曲线密码学）的缩写，是一种基于椭圆曲线数学的公开密钥加密算法，其本质是利用离散对数问题实现加密。ECC的主要优势，是在使用更小的密钥的同时，提供更快的性能和更高等级的安全。</p>
      <h2>什么是椭圆曲线</h2>
      <p>一条椭圆曲线就是一组被 y^2 = x^3 + ax + b 定义的且满足 4a^3 + 27b^2 ≠ 0 的点集。</p>
      <p>4a^3 + 27b^2 ≠ 0 这个限定条件是为了保证曲线不包含奇点（在数学中是指曲线上任意一点都存在切线）。
椭圆曲线示例图：</p>
      <div>
        <img src='https://segmentfault.com/img/bVbsBEV?w=561&h=456'></img>
      </div>
      <p>不同的椭圆曲线对应不同的形状（b=1，a从2到-3)</p>
      <div>
        <img src="https://segmentfault.com/img/bVbsBFL?w=332&h=227" alt="" />
      </div>
      <p>左（带锐点）：y^2 = x^3</p>
      <p>右（曲线自交）：y^2 = x^3 -3x + 2</p>
      <p>都不是有效的椭圆曲线</p>
      <h2>关于阿贝尔群(abelian group)</h2>
      <p>阿贝尔群的概念是抽象代数的基本概念之一，是一种代数结构，由一个集合以及一个二元运算所组成。如果一个集合或者运算是群的话，就必须满足以下条件（+ 表示二元运算）：</p>
      <ol>
        <li>封闭性（closure），如果a和b被包含于群，那么a+b也一定是群的元素；</li>
        <li>结合律(associativity)；</li>
        <li>存在一个单位元（identity element）0，0与任意元素运算不改变其值的元素，即 a+0 = 0+a = a；</li>
        <li>每个元素都存在一个逆元(inverse)；</li>
        <li>交换律(commutativity)，即 a+b = b+a；</li>
        <h2>椭圆曲线中的阿贝尔群</h2>
        <p>我们可以在椭圆曲线上定义一个群：</p>
        <ol>
          <li>群中的元素就是椭圆曲线上的点；</li>
          <li>单位元就是无穷处的点0；</li>
          <li>相反数P，是关于X轴对称的另一边的点；</li>
          <li>二元运算规则定义如下：取一条直线上的三点（这条直线和椭圆曲线相交的三点），P, Q, R（皆非零），他们的总和等于0，
P+Q+R=0。</li>
        </ol>
        <img src="https://segmentfault.com/img/bVbsBIP?w=474&h=350" alt="" />
        <p>如果P, Q, R在一条直线上的话，他们满足:</p>
        <p> P+(Q+R)=Q+(P+R)=R+(P+Q)=⋯=0。</p>
        <p>当P，Q点为同一点时,P=Q，满足：</p>
        <img src="https://segmentfault.com/img/bVbsBI0?w=344&h=319" alt="" />
        <p>这样，我们可以直观的证明：+运算符是符合交换律和结合律的，这是一个阿贝尔群。</p>
        <p>因为阿贝尔群满足交换律和结合律，所以点P和点-R的二元运算结果必会在曲线上，即P+P+P的结果必会在曲线上的另一点Q，
以此类推，可以得出得出：</p>
        <p> Q=kP(k个相同的点P进行二元运算（数乘）,记做kP)</p>
        <h2>离散对数问题</h2>
        <p>前文中有提到离散对数问题，我们熟悉的RSA算法，是基于大数的质因数分解，即对两个质数相乘容易，而将其合数分解很难的这个特点进行加密。</p>
        <p>而ECC算法是在有限域Fp定义公式：Q=kP，已知大数k和点P的情况下，很容易求点Q，但是已知的点P、点Q，却很难求得k，这就是经典的离散对数问题，ECC算法正是利用该特点进行加密，点Q为公钥，大数k为私钥，点P为基点，和RSA最大的实际区别，主要是密钥长度</p>
        <h2>椭圆曲线加密算法原理</h2>
        <p>描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,n,x,y)。
（p 、a 、b） 用来确定一条椭圆曲线，p为素数域内点的个数，a和b是其内的两个大数；
</p>
        <p>x,y为G基点的坐标，也是两个大数；
</p>
        <p>n为点G基点的阶；
</p>
        <p>以上六个量就可以描述一条椭圆曲线，有时候我们还会用到h(椭圆曲线上所有点的个数p与n相除的整数部分)。</p>
        <p>现在我们描述一个利用椭圆曲线进行加密通信的过程：</p>
        <ol>
          <li>选定一条椭圆曲线 Ep(a,b) 并取椭圆曲线上一点，作为基点P。</li>
          <li>选择一个大数k作为私钥，并生成公钥 Q=kP。</li>
          <li>将 Ep(a,b) 和点Q、P传给用户。</li>
          <li>用户接到信息后 ，将待传输的明文编码到Ep(a,b)上的一点M，并产生一个随机整数r。</li>
          <li>{`公钥加密（密文C是一个点对）：C={rP, M+rQ}`}</li>
          <li>{`私钥解密（M + rQ - k(rP) ，解密结果就是点M），公式如下： M + rQ - k(rP) = M + r(kP) - k(rP) = M`}</li>
          <li>对点M进行解码就可以得到明文,假设在加密过程中，有一个第三者H，H只能知道椭圆曲线 Ep(a,b)、公钥Q、基点P、密文点C，而通过公钥Q、基点P求私钥k或者通过密文点C、基点P求随机数r都是非常困难的，因此得以保证数据传输的安全。</li>
        </ol>
      </ol>
    </div>
  )
};

export default EccInfo;
