import React from 'react';

import './index.less';

const AesInfo = () => {
  return (
    <div className='aes-info'>
      <h2>AES算法简介</h2>
      <p>AES的全称是Advanced Encryption Standard，意思是高级加密标准。它的出现主要是为了取代DES加密算法的，因为我们都知道DES算法的密钥长度是56Bit，因此算法的理论安全强度是2的56次方。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，虽然出现了3DES的加密方法，但由于它的加密时间是DES算法的3倍多，64Bit的分组大小相对较小，所以还是不能满足人们对安全性的要求。于是1997年1月2号，美国国家标准技术研究所宣布希望征集高级加密标准，用以取代DES。AES也得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜</p>
      <p>在密码标准征集中，所有AES候选提交方案都必须满足以下标准：</p>
      <ol>
        <li>分组大小为128位的分组密码</li>
        <li>必须支持三种密码标准：128位、192位和256位。</li>
        <li>比提交的其他算法更安全。</li>
        <li>在软件和硬件实现上都很高效。</li>
      </ol>
      <p>AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位和256位。然而AES只要求分组大小为128位，因此只有分组长度为128Bit的Rijndael才称为AES算法。本文只对分组大小128位，密钥长度也为128位的Rijndael算法进行分析。密钥长度为192位和256位的处理方式和128位的处理方式类似，只不过密钥长度每增加64位，算法的循环次数就增加2轮，128位循环10轮、192位循环12轮、256位循环14轮。</p>
      <h2>AES算法原理</h2>
      <p>AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度，暂时不考虑)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，我们只考虑128位密钥的10轮处理。接下来，就开始一步步的介绍AES算法的处理流程了。</p>
      <img src="https://pic1.zhimg.com/80/v2-fe04b0967fd0a6581b083e42a47a546c_1440w.webp" alt="" />
      <p>AES算法流程图</p>
      <img src="https://pic4.zhimg.com/80/v2-b22e3bdd7da5ddf5ea6ff71909dac4b7_1440w.webp" alt="" />
      <p>密钥加法层</p>
      <p>在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。k[0]实际上就等同于密钥k，具体原因在密钥生成中进行介绍。我们前面在介绍扩展域加减法中提到过，在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。</p>
      <img src="https://pic3.zhimg.com/80/v2-cab03da551aafad821676824c1bc6ebe_1440w.webp" alt="" />
      <p>字节代换层</p>
      <p>字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，这里的S_box表是通过某种方法计算出来的，具体的计算方法将在进阶部分进行介绍，我们基础部分就只给出计算好的S_box结果。S_box表是一个拥有256个字节元素的数组，可以将其定义为一维数组，也可以将其定义为16·16的二维数组，如果将其定义为二维数组，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标，略有点麻烦。这里建议将其视作一维数组即可。逆S盒与S盒对应，用于解密时对数据处理，我们对解密时的程序处理称作逆字节代换，只是使用的代换表盒加密时不同而已。</p>
      <p>S盒</p>
      <img src="https://pic1.zhimg.com/80/v2-e160744c78b680b008c165cb78841858_1440w.webp" alt="" />
      <p>逆S盒</p>
      <img src="https://pic2.zhimg.com/80/v2-11d806427bd01e1f3c267504e56b3841_1440w.webp" alt="" />
      <p>加密图示：</p>
      <img src="https://pic1.zhimg.com/80/v2-83b41eb29d3e797bafdc4d669365bf5c_1440w.webp" alt="" />
      <p>行位移——ShiftRows</p>
      <p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到雪崩效应。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。操作结束！

</p>
      <p>正向行位移图解:</p>
      <img src="https://pic2.zhimg.com/80/v2-581b444c6583aff31afe66b0391d73c1_1440w.webp" alt="" />
      <p>逆向行位移图解:</p>
      <img src="https://pic3.zhimg.com/80/v2-d90578c8b7a5942cc18bc2f1d0618b76_1440w.webp" alt="" />
      <p>列混淆——MixColumn</p>
      <p>列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。</p>
      <p></p>
    </div>
  )
};

export default AesInfo;
